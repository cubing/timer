var define;
!function webpackUniversalModuleDefinition(root, factory) {
  "object" == typeof exports && "object" == typeof module ? module.exports = factory() : "function" == typeof define && define.amd ? define([], factory) : "object" == typeof exports ? exports.alg = factory() : root.alg = factory();
}("undefined" != typeof self ? self : this, function () {
  return function (modules) {
    var installedModules = {};

    function __webpack_require__(moduleId) {
      if (installedModules[moduleId]) return installedModules[moduleId].exports;
      var module = installedModules[moduleId] = {
        i: moduleId,
        l: !1,
        exports: {}
      };
      return modules[moduleId].call(module.exports, module, module.exports, __webpack_require__), module.l = !0, module.exports;
    }

    return __webpack_require__.m = modules, __webpack_require__.c = installedModules, __webpack_require__.d = function (exports, name, getter) {
      __webpack_require__.o(exports, name) || Object.defineProperty(exports, name, {
        enumerable: !0,
        get: getter
      });
    }, __webpack_require__.r = function (exports) {
      "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(exports, Symbol.toStringTag, {
        value: "Module"
      }), Object.defineProperty(exports, "__esModule", {
        value: !0
      });
    }, __webpack_require__.t = function (value, mode) {
      if (1 & mode && (value = __webpack_require__(value)), 8 & mode) return value;
      if (4 & mode && "object" == typeof value && value && value.__esModule) return value;
      var ns = Object.create(null);
      if (__webpack_require__.r(ns), Object.defineProperty(ns, "default", {
        enumerable: !0,
        value: value
      }), 2 & mode && "string" != typeof value) for (var key in value) __webpack_require__.d(ns, key, function (key) {
        return value[key];
      }.bind(null, key));
      return ns;
    }, __webpack_require__.n = function (module) {
      var getter = module && module.__esModule ? function getDefault() {
        return module.default;
      } : function getModuleExports() {
        return module;
      };
      return __webpack_require__.d(getter, "a", getter), getter;
    }, __webpack_require__.o = function (object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    }, __webpack_require__.p = "", __webpack_require__(__webpack_require__.s = 1);
  }([function (module, exports, __webpack_require__) {
    var index = function () {
      var o = function (k, v, o, l) {
        for (o = o || {}, l = k.length; l--; o[k[l]] = v);

        return o;
      },
          $V0 = [2, 14],
          $V1 = [1, 5],
          $V2 = [5, 23, 24, 25, 27],
          $V3 = [1, 23],
          $V4 = [1, 18],
          $V5 = [1, 19],
          $V6 = [1, 22],
          $V7 = [1, 16],
          $V8 = [1, 17],
          $V9 = [1, 12],
          $Va = [1, 13],
          $Vb = [5, 7, 12, 13, 15, 21, 23, 24, 25, 26, 27, 30, 31],
          $Vc = [5, 19, 23, 24, 25, 27],
          $Vd = [5, 12, 13, 19, 23, 24, 25, 27, 30, 31],
          $Ve = [5, 7, 12, 13, 15, 19, 21, 23, 24, 25, 26, 27, 30, 31],
          $Vf = [5, 7, 10, 12, 13, 19, 23, 24, 25, 27, 30, 31],
          $Vg = [7, 12, 13, 15, 21, 24, 26, 30, 31],
          parser = {
        trace: function trace() {},
        yy: {},
        symbols_: {
          error: 2,
          expressions: 3,
          TOP_LEVEL_ALG: 4,
          EOF: 5,
          LAYER: 6,
          NUMBER: 7,
          REPETITION: 8,
          AMOUNT: 9,
          PRIME: 10,
          COMMENT: 11,
          COMMENT_SHORT: 12,
          COMMENT_LONG: 13,
          FAMILY: 14,
          LONG_FAMILY: 15,
          BLOCK_MOVE: 16,
          DASH: 17,
          OPTIONAL_WHITESPACE: 18,
          WHITESPACE: 19,
          REPEATABLE_UNIT: 20,
          OPEN_BRACKET: 21,
          SEQUENCE: 22,
          COMMA: 23,
          CLOSE_BRACKET: 24,
          COLON: 25,
          OPEN_PARENTHESIS: 26,
          CLOSE_PARENTHESIS: 27,
          REPEATED_UNIT: 28,
          ANNOTATION: 29,
          NEWLINE: 30,
          PAUSE: 31,
          UNIT_LIST_WITHOUT_WHITESPACE: 32,
          UNIT_LIST: 33,
          $accept: 0,
          $end: 1
        },
        terminals_: {
          2: "error",
          5: "EOF",
          7: "NUMBER",
          10: "PRIME",
          12: "COMMENT_SHORT",
          13: "COMMENT_LONG",
          15: "LONG_FAMILY",
          17: "DASH",
          19: "WHITESPACE",
          21: "OPEN_BRACKET",
          23: "COMMA",
          24: "CLOSE_BRACKET",
          25: "COLON",
          26: "OPEN_PARENTHESIS",
          27: "CLOSE_PARENTHESIS",
          30: "NEWLINE",
          31: "PAUSE"
        },
        productions_: [0, [3, 2], [6, 1], [8, 1], [9, 1], [9, 2], [9, 1], [11, 1], [11, 1], [14, 1], [16, 1], [16, 2], [16, 4], [18, 2], [18, 0], [20, 1], [20, 5], [20, 5], [20, 3], [20, 1], [20, 5], [20, 5], [20, 3], [28, 1], [28, 2], [29, 1], [29, 1], [29, 1], [32, 1], [32, 3], [32, 2], [32, 2], [32, 1], [33, 1], [33, 3], [22, 3], [22, 1], [4, 1]],
        performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$) {
          var $0 = $$.length - 1;

          switch (yystate) {
            case 1:
              return $$[$0 - 1];

            case 2:
            case 3:
              this.$ = parseInt($$[$0]);
              break;

            case 5:
              this.$ = -$$[$0 - 1];
              break;

            case 6:
              this.$ = -1;
              break;

            case 7:
              this.$ = {
                type: "commentShort",
                comment: $$[$0].slice(2)
              };
              break;

            case 8:
              this.$ = {
                type: "commentLong",
                comment: $$[$0].slice(2, -2)
              };
              break;

            case 10:
              this.$ = {
                type: "blockMove",
                family: $$[$0]
              };
              break;

            case 11:
              this.$ = {
                type: "blockMove",
                family: $$[$0],
                innerLayer: $$[$0 - 1]
              };
              break;

            case 12:
              this.$ = {
                type: "blockMove",
                family: $$[$0],
                outerLayer: $$[$0 - 3],
                innerLayer: $$[$0 - 1]
              };
              break;

            case 16:
            case 20:
              this.$ = {
                type: "commutator",
                A: $$[$0 - 3],
                B: $$[$0 - 1]
              };
              break;

            case 17:
            case 21:
              this.$ = {
                type: "conjugate",
                A: $$[$0 - 3],
                B: $$[$0 - 1]
              };
              break;

            case 18:
            case 22:
              this.$ = {
                type: "group",
                nestedSequence: $$[$0 - 1]
              };
              break;

            case 23:
              $$[$0].amount = 1, this.$ = $$[$0];
              break;

            case 24:
              $$[$0 - 1].amount = $$[$0], this.$ = $$[$0 - 1];
              break;

            case 25:
              this.$ = {
                type: "newLine"
              };
              break;

            case 26:
              this.$ = {
                type: "pause"
              };
              break;

            case 28:
            case 32:
              this.$ = [$$[$0]];
              break;

            case 29:
              this.$ = $$[$0 - 2].concat([$$[$0 - 1]]).concat($$[$0]);
              break;

            case 30:
              this.$ = [$$[$0 - 1]].concat($$[$0]);
              break;

            case 31:
              this.$ = $$[$0 - 1].concat([$$[$0]]);
              break;

            case 33:
            case 37:
              this.$ = $$[$0];
              break;

            case 34:
              this.$ = $$[$0 - 2].concat($$[$0]);
              break;

            case 35:
              this.$ = {
                type: "sequence",
                nestedUnits: $$[$0 - 1]
              };
              break;

            case 36:
              this.$ = {
                type: "sequence",
                nestedUnits: []
              };
          }
        },
        table: [o([5, 7, 12, 13, 15, 21, 26, 30, 31], $V0, {
          3: 1,
          4: 2,
          22: 3,
          18: 4,
          19: $V1
        }), {
          1: [3]
        }, {
          5: [1, 6]
        }, {
          5: [2, 37]
        }, o($V2, [2, 36], {
          33: 7,
          32: 8,
          28: 9,
          29: 10,
          20: 11,
          11: 14,
          16: 15,
          14: 20,
          6: 21,
          7: $V3,
          12: $V4,
          13: $V5,
          15: $V6,
          21: $V7,
          26: $V8,
          30: $V9,
          31: $Va
        }), o($Vb, $V0, {
          18: 24,
          19: $V1
        }), {
          1: [2, 1]
        }, o($V2, $V0, {
          18: 25,
          19: [1, 26]
        }), o($Vc, [2, 33], {
          11: 14,
          29: 27,
          12: $V4,
          13: $V5,
          30: $V9,
          31: $Va
        }), o($Vd, [2, 28]), o($Vc, [2, 32], {
          28: 9,
          29: 10,
          20: 11,
          11: 14,
          16: 15,
          14: 20,
          6: 21,
          32: 28,
          7: $V3,
          12: $V4,
          13: $V5,
          15: $V6,
          21: $V7,
          26: $V8,
          30: $V9,
          31: $Va
        }), o($Vd, [2, 23], {
          9: 29,
          8: 30,
          7: [1, 32],
          10: [1, 31]
        }), o($Ve, [2, 25]), o($Ve, [2, 26]), o($Ve, [2, 27]), o($Vf, [2, 15]), o([7, 12, 13, 15, 21, 23, 25, 26, 30, 31], $V0, {
          18: 4,
          22: 33,
          19: $V1
        }), o([7, 12, 13, 15, 21, 26, 27, 30, 31], $V0, {
          18: 4,
          22: 34,
          19: $V1
        }), o($Ve, [2, 7]), o($Ve, [2, 8]), o($Vf, [2, 10]), {
          14: 35,
          15: $V6,
          17: [1, 36]
        }, o($Vf, [2, 9]), o([15, 17], [2, 2]), o($Vb, [2, 13]), o($V2, [2, 35]), o($V2, $V0, {
          28: 9,
          29: 10,
          20: 11,
          11: 14,
          16: 15,
          14: 20,
          6: 21,
          18: 24,
          32: 37,
          7: $V3,
          12: $V4,
          13: $V5,
          15: $V6,
          19: $V1,
          21: $V7,
          26: $V8,
          30: $V9,
          31: $Va
        }), o($Vc, [2, 31], {
          28: 9,
          29: 10,
          20: 11,
          11: 14,
          16: 15,
          14: 20,
          6: 21,
          32: 38,
          7: $V3,
          12: $V4,
          13: $V5,
          15: $V6,
          21: $V7,
          26: $V8,
          30: $V9,
          31: $Va
        }), o($Vc, [2, 30], {
          11: 14,
          29: 27,
          12: $V4,
          13: $V5,
          30: $V9,
          31: $Va
        }), o($Vd, [2, 24]), o($Vd, [2, 4], {
          10: [1, 39]
        }), o($Vd, [2, 6]), o([5, 10, 12, 13, 19, 23, 24, 25, 27, 30, 31], [2, 3]), {
          23: [1, 40],
          25: [1, 41]
        }, {
          27: [1, 42]
        }, o($Vf, [2, 11]), {
          6: 43,
          7: $V3
        }, o($Vc, [2, 34], {
          11: 14,
          29: 27,
          12: $V4,
          13: $V5,
          30: $V9,
          31: $Va
        }), o($Vc, [2, 29], {
          11: 14,
          29: 27,
          12: $V4,
          13: $V5,
          30: $V9,
          31: $Va
        }), o($Vd, [2, 5]), o($Vg, $V0, {
          18: 4,
          22: 44,
          19: $V1
        }), o($Vg, $V0, {
          18: 4,
          22: 45,
          19: $V1
        }), o($Vf, [2, 18]), {
          14: 46,
          15: $V6
        }, {
          24: [1, 47]
        }, {
          24: [1, 48]
        }, o($Vf, [2, 12]), o($Vf, [2, 16]), o($Vf, [2, 17])],
        defaultActions: {
          3: [2, 37],
          6: [2, 1]
        },
        parseError: function parseError(str, hash) {
          if (!hash.recoverable) {
            var error = new Error(str);
            throw error.hash = hash, error;
          }

          this.trace(str);
        },
        parse: function parse(input) {
          var self = this,
              stack = [0],
              vstack = [null],
              lstack = [],
              table = this.table,
              yytext = "",
              yylineno = 0,
              yyleng = 0,
              recovering = 0,
              args = lstack.slice.call(arguments, 1),
              lexer = Object.create(this.lexer),
              sharedState = {
            yy: {}
          };

          for (var k in this.yy) Object.prototype.hasOwnProperty.call(this.yy, k) && (sharedState.yy[k] = this.yy[k]);

          lexer.setInput(input, sharedState.yy), sharedState.yy.lexer = lexer, sharedState.yy.parser = this, void 0 === lexer.yylloc && (lexer.yylloc = {});
          var yyloc = lexer.yylloc;
          lstack.push(yyloc);
          var ranges = lexer.options && lexer.options.ranges;
          "function" == typeof sharedState.yy.parseError ? this.parseError = sharedState.yy.parseError : this.parseError = Object.getPrototypeOf(this).parseError;

          for (var symbol, preErrorSymbol, state, action, r, p, len, newState, expected, lex = function () {
            var token;
            return "number" != typeof (token = lexer.lex() || 1) && (token = self.symbols_[token] || token), token;
          }, yyval = {};;) {
            if (state = stack[stack.length - 1], this.defaultActions[state] ? action = this.defaultActions[state] : (null == symbol && (symbol = lex()), action = table[state] && table[state][symbol]), void 0 === action || !action.length || !action[0]) {
              var errStr = "";

              for (p in expected = [], table[state]) this.terminals_[p] && p > 2 && expected.push("'" + this.terminals_[p] + "'");

              errStr = lexer.showPosition ? "Parse error on line " + (yylineno + 1) + ":\n" + lexer.showPosition() + "\nExpecting " + expected.join(", ") + ", got '" + (this.terminals_[symbol] || symbol) + "'" : "Parse error on line " + (yylineno + 1) + ": Unexpected " + (1 == symbol ? "end of input" : "'" + (this.terminals_[symbol] || symbol) + "'"), this.parseError(errStr, {
                text: lexer.match,
                token: this.terminals_[symbol] || symbol,
                line: lexer.yylineno,
                loc: yyloc,
                expected: expected
              });
            }

            if (action[0] instanceof Array && action.length > 1) throw new Error("Parse Error: multiple actions possible at state: " + state + ", token: " + symbol);

            switch (action[0]) {
              case 1:
                stack.push(symbol), vstack.push(lexer.yytext), lstack.push(lexer.yylloc), stack.push(action[1]), symbol = null, preErrorSymbol ? (symbol = preErrorSymbol, preErrorSymbol = null) : (yyleng = lexer.yyleng, yytext = lexer.yytext, yylineno = lexer.yylineno, yyloc = lexer.yylloc, recovering > 0 && recovering--);
                break;

              case 2:
                if (len = this.productions_[action[1]][1], yyval.$ = vstack[vstack.length - len], yyval._$ = {
                  first_line: lstack[lstack.length - (len || 1)].first_line,
                  last_line: lstack[lstack.length - 1].last_line,
                  first_column: lstack[lstack.length - (len || 1)].first_column,
                  last_column: lstack[lstack.length - 1].last_column
                }, ranges && (yyval._$.range = [lstack[lstack.length - (len || 1)].range[0], lstack[lstack.length - 1].range[1]]), void 0 !== (r = this.performAction.apply(yyval, [yytext, yyleng, yylineno, sharedState.yy, action[1], vstack, lstack].concat(args)))) return r;
                len && (stack = stack.slice(0, -1 * len * 2), vstack = vstack.slice(0, -1 * len), lstack = lstack.slice(0, -1 * len)), stack.push(this.productions_[action[1]][0]), vstack.push(yyval.$), lstack.push(yyval._$), newState = table[stack[stack.length - 2]][stack[stack.length - 1]], stack.push(newState);
                break;

              case 3:
                return !0;
            }
          }

          return !0;
        }
      },
          lexer = {
        EOF: 1,
        parseError: function parseError(str, hash) {
          if (!this.yy.parser) throw new Error(str);
          this.yy.parser.parseError(str, hash);
        },
        setInput: function (input, yy) {
          return this.yy = yy || this.yy || {}, this._input = input, this._more = this._backtrack = this.done = !1, this.yylineno = this.yyleng = 0, this.yytext = this.matched = this.match = "", this.conditionStack = ["INITIAL"], this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
          }, this.options.ranges && (this.yylloc.range = [0, 0]), this.offset = 0, this;
        },
        input: function () {
          var ch = this._input[0];
          return this.yytext += ch, this.yyleng++, this.offset++, this.match += ch, this.matched += ch, ch.match(/(?:\r\n?|\n).*/g) ? (this.yylineno++, this.yylloc.last_line++) : this.yylloc.last_column++, this.options.ranges && this.yylloc.range[1]++, this._input = this._input.slice(1), ch;
        },
        unput: function (ch) {
          var len = ch.length,
              lines = ch.split(/(?:\r\n?|\n)/g);
          this._input = ch + this._input, this.yytext = this.yytext.substr(0, this.yytext.length - len), this.offset -= len;
          var oldLines = this.match.split(/(?:\r\n?|\n)/g);
          this.match = this.match.substr(0, this.match.length - 1), this.matched = this.matched.substr(0, this.matched.length - 1), lines.length - 1 && (this.yylineno -= lines.length - 1);
          var r = this.yylloc.range;
          return this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ? (lines.length === oldLines.length ? this.yylloc.first_column : 0) + oldLines[oldLines.length - lines.length].length - lines[0].length : this.yylloc.first_column - len
          }, this.options.ranges && (this.yylloc.range = [r[0], r[0] + this.yyleng - len]), this.yyleng = this.yytext.length, this;
        },
        more: function () {
          return this._more = !0, this;
        },
        reject: function () {
          return this.options.backtrack_lexer ? (this._backtrack = !0, this) : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        },
        less: function (n) {
          this.unput(this.match.slice(n));
        },
        pastInput: function () {
          var past = this.matched.substr(0, this.matched.length - this.match.length);
          return (past.length > 20 ? "..." : "") + past.substr(-20).replace(/\n/g, "");
        },
        upcomingInput: function () {
          var next = this.match;
          return next.length < 20 && (next += this._input.substr(0, 20 - next.length)), (next.substr(0, 20) + (next.length > 20 ? "..." : "")).replace(/\n/g, "");
        },
        showPosition: function () {
          var pre = this.pastInput(),
              c = new Array(pre.length + 1).join("-");
          return pre + this.upcomingInput() + "\n" + c + "^";
        },
        test_match: function (match, indexed_rule) {
          var token, lines, backup;
          if (this.options.backtrack_lexer && (backup = {
            yylineno: this.yylineno,
            yylloc: {
              first_line: this.yylloc.first_line,
              last_line: this.last_line,
              first_column: this.yylloc.first_column,
              last_column: this.yylloc.last_column
            },
            yytext: this.yytext,
            match: this.match,
            matches: this.matches,
            matched: this.matched,
            yyleng: this.yyleng,
            offset: this.offset,
            _more: this._more,
            _input: this._input,
            yy: this.yy,
            conditionStack: this.conditionStack.slice(0),
            done: this.done
          }, this.options.ranges && (backup.yylloc.range = this.yylloc.range.slice(0))), (lines = match[0].match(/(?:\r\n?|\n).*/g)) && (this.yylineno += lines.length), this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ? lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length : this.yylloc.last_column + match[0].length
          }, this.yytext += match[0], this.match += match[0], this.matches = match, this.yyleng = this.yytext.length, this.options.ranges && (this.yylloc.range = [this.offset, this.offset += this.yyleng]), this._more = !1, this._backtrack = !1, this._input = this._input.slice(match[0].length), this.matched += match[0], token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]), this.done && this._input && (this.done = !1), token) return token;

          if (this._backtrack) {
            for (var k in backup) this[k] = backup[k];

            return !1;
          }

          return !1;
        },
        next: function () {
          if (this.done) return this.EOF;
          var token, match, tempMatch, index;
          this._input || (this.done = !0), this._more || (this.yytext = "", this.match = "");

          for (var rules = this._currentRules(), i = 0; i < rules.length; i++) if ((tempMatch = this._input.match(this.rules[rules[i]])) && (!match || tempMatch[0].length > match[0].length)) {
            if (match = tempMatch, index = i, this.options.backtrack_lexer) {
              if (!1 !== (token = this.test_match(tempMatch, rules[i]))) return token;

              if (this._backtrack) {
                match = !1;
                continue;
              }

              return !1;
            }

            if (!this.options.flex) break;
          }

          return match ? !1 !== (token = this.test_match(match, rules[index])) && token : "" === this._input ? this.EOF : this.parseError("Lexical error on line " + (this.yylineno + 1) + ". Unrecognized text.\n" + this.showPosition(), {
            text: "",
            token: null,
            line: this.yylineno
          });
        },
        lex: function lex() {
          var r = this.next();
          return r || this.lex();
        },
        begin: function begin(condition) {
          this.conditionStack.push(condition);
        },
        popState: function popState() {
          return this.conditionStack.length - 1 > 0 ? this.conditionStack.pop() : this.conditionStack[0];
        },
        _currentRules: function _currentRules() {
          return this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1] ? this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules : this.conditions.INITIAL.rules;
        },
        topState: function topState(n) {
          return (n = this.conditionStack.length - 1 - Math.abs(n || 0)) >= 0 ? this.conditionStack[n] : "INITIAL";
        },
        pushState: function pushState(condition) {
          this.begin(condition);
        },
        stateStackSize: function stateStackSize() {
          return this.conditionStack.length;
        },
        options: {},
        performAction: function anonymous(yy, yy_, $avoiding_name_collisions, YY_START) {
          switch ($avoiding_name_collisions) {
            case 0:
              return "WHITESPACE";

            case 1:
              return "NUMBER";

            case 2:
              return "DASH";

            case 3:
              return "LONG_FAMILY";

            case 4:
              return "PRIME";

            case 5:
              return "PAUSE";

            case 6:
              return "COMMENT_SHORT";

            case 7:
              return "COMMENT_LONG";

            case 8:
              return "NEWLINE";

            case 9:
              return "OPEN_BRACKET";

            case 10:
              return "CLOSE_BRACKET";

            case 11:
              return "OPEN_PARENTHESIS";

            case 12:
              return "CLOSE_PARENTHESIS";

            case 13:
              return "COMMA";

            case 14:
              return "COLON";

            case 15:
              return "EOF";

            case 16:
              return "INVALID";
          }
        },
        rules: [/^(?:[^\S\r\n]+)/, /^(?:[0-9]+)/, /^(?:-)/, /^(?:[_A-Za-z]+)/, /^(?:')/, /^(?:\.)/, /^(?:\/\/[^\n\r]*)/, /^(?:\/\*[^]*?\*\/)/, /^(?:[\n\r])/, /^(?:\[)/, /^(?:\])/, /^(?:\()/, /^(?:\))/, /^(?:,)/, /^(?::)/, /^(?:$)/, /^(?:.)/],
        conditions: {
          INITIAL: {
            rules: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16],
            inclusive: !0
          }
        }
      };

      function Parser() {
        this.yy = {};
      }

      return parser.lexer = lexer, Parser.prototype = parser, parser.Parser = Parser, new Parser();
    }();

    exports.parser = index, exports.Parser = index.Parser, exports.parse = function () {
      return index.parse.apply(index, arguments);
    };
  }, function (module, __webpack_exports__, __webpack_require__) {
    "use strict";

    __webpack_require__.r(__webpack_exports__);

    var currentReportingLevel = "warn",
        MAX_NUMBER_OF_TIMES_TO_WARN = 10,
        numWarned = 0;

    function reportTypeMismatch(msg) {
      switch (currentReportingLevel) {
        case "error":
          throw msg;

        case "warn":
          return void (++numWarned < MAX_NUMBER_OF_TIMES_TO_WARN && numWarned + 1 == MAX_NUMBER_OF_TIMES_TO_WARN && console.warn(msg));
      }
    }

    function setAlgPartTypeMismatchReportingLevel(level) {
      currentReportingLevel = level;
    }

    class AlgPart {}

    function matchesAlgType(a, t) {
      return a.type == t;
    }

    function assertMatchesType(a, t) {
      return matchesAlgType(a, t) || reportTypeMismatch(`Expected "type": "${t}", saw "type": "${a.type}".`), a;
    }

    function isUnit(a) {
      return "type" in a && !matchesAlgType(a, "sequence");
    }

    function assertIsUnit(a) {
      return "type" in a || reportTypeMismatch('Expected "unit", saw a value that was not an AlgPart.'), matchesAlgType(a, "sequence") && reportTypeMismatch('Expected unit, saw "sequence".'), a;
    }

    class Unit extends AlgPart {}

    class Move extends Unit {}

    class Annotation extends Unit {}

    class Container extends Unit {}

    class Sequence extends AlgPart {
      constructor(nestedUnits) {
        super(), this.nestedUnits = nestedUnits, this.type = "sequence";

        for (const n of nestedUnits) assertIsUnit(n);

        Object.freeze(this.nestedUnits), Object.freeze(this);
      }

    }

    class Group extends Container {
      constructor(nestedSequence, amount = 1) {
        super(), this.nestedSequence = nestedSequence, this.amount = amount, this.type = "group", Object.freeze(this);
      }

    }

    class Commutator extends Container {
      constructor(A, B, amount = 1) {
        super(), this.A = A, this.B = B, this.amount = amount, this.type = "commutator", Object.freeze(this);
      }

    }

    class Conjugate extends Container {
      constructor(A, B, amount = 1) {
        super(), this.A = A, this.B = B, this.amount = amount, this.type = "conjugate", Object.freeze(this);
      }

    }

    class Pause extends Move {
      constructor() {
        super(), this.type = "pause", Object.freeze(this);
      }

    }

    class NewLine extends Annotation {
      constructor() {
        super(), this.type = "newLine", Object.freeze(this);
      }

    }

    class CommentShort extends Annotation {
      constructor(comment) {
        super(), this.comment = comment, this.type = "commentShort", Object.freeze(this);
      }

    }

    class CommentLong extends Annotation {
      constructor(comment) {
        super(), this.comment = comment, this.type = "commentLong", Object.freeze(this);
      }

    }

    class block_move_BlockMove extends Move {
      constructor(outerLayer, innerLayer, family, amount = 1) {
        super(), this.family = family, this.amount = amount, this.type = "blockMove", this.outerLayer = outerLayer, this.innerLayer = innerLayer, Object.freeze(this);
      }

    }

    function BareBlockMove(family, amount) {
      return new block_move_BlockMove(void 0, void 0, family, amount);
    }

    function LayerBlockMove(innerLayer, family, amount) {
      return new block_move_BlockMove(void 0, innerLayer, family, amount);
    }

    function RangeBlockMove(outerLayer, innerLayer, family, amount) {
      return new block_move_BlockMove(outerLayer, innerLayer, family, amount);
    }

    function dispatch(t, algPart, dataDown) {
      switch (algPart.type) {
        case "sequence":
          return assertMatchesType(algPart, "sequence"), t.traverseSequence(algPart, dataDown);

        case "group":
          return assertMatchesType(algPart, "group"), t.traverseGroup(algPart, dataDown);

        case "blockMove":
          return assertMatchesType(algPart, "blockMove"), t.traverseBlockMove(algPart, dataDown);

        case "commutator":
          return assertMatchesType(algPart, "commutator"), t.traverseCommutator(algPart, dataDown);

        case "conjugate":
          return assertMatchesType(algPart, "conjugate"), t.traverseConjugate(algPart, dataDown);

        case "pause":
          return assertMatchesType(algPart, "pause"), t.traversePause(algPart, dataDown);

        case "newLine":
          return assertMatchesType(algPart, "newLine"), t.traverseNewLine(algPart, dataDown);

        case "commentShort":
          return assertMatchesType(algPart, "commentShort"), t.traverseCommentShort(algPart, dataDown);

        case "commentLong":
          return assertMatchesType(algPart, "commentLong"), t.traverseCommentLong(algPart, dataDown);

        default:
          throw `Unknown AlgPart type: ${algPart.type}`;
      }
    }

    class traversal_TraversalDownUp {
      traverse(algPart, dataDown) {
        return dispatch(this, algPart, dataDown);
      }

      traverseIntoUnit(algPart, dataDown) {
        return assertIsUnit(this.traverse(algPart, dataDown));
      }

    }

    class traversal_TraversalUp extends traversal_TraversalDownUp {
      traverse(algPart) {
        return dispatch(this, algPart, void 0);
      }

      traverseIntoUnit(algPart) {
        return assertIsUnit(this.traverse(algPart));
      }

    }

    const invertInstance = new class traversal_Invert extends traversal_TraversalUp {
      traverseSequence(sequence) {
        return new Sequence(sequence.nestedUnits.slice().reverse().map(a => this.traverseIntoUnit(a)));
      }

      traverseGroup(group) {
        return new Group(this.traverseSequence(group.nestedSequence), group.amount);
      }

      traverseBlockMove(blockMove) {
        return new block_move_BlockMove(blockMove.outerLayer, blockMove.innerLayer, blockMove.family, -blockMove.amount);
      }

      traverseCommutator(commutator) {
        return new Commutator(commutator.B, commutator.A, commutator.amount);
      }

      traverseConjugate(conjugate) {
        return new Conjugate(conjugate.A, this.traverseSequence(conjugate.B), conjugate.amount);
      }

      traversePause(pause) {
        return pause;
      }

      traverseNewLine(newLine) {
        return newLine;
      }

      traverseCommentShort(commentShort) {
        return commentShort;
      }

      traverseCommentLong(commentLong) {
        return commentLong;
      }

    }(),
          expandInstance = new class traversal_Expand extends traversal_TraversalUp {
      flattenSequenceOneLevel(algList) {
        var flattened = [];

        for (const part of algList) if (matchesAlgType(part, "sequence")) flattened = flattened.concat(part.nestedUnits);else {
          if (!isUnit(part)) throw "expand() encountered an internal error. Did you pass in a valid Algorithm?";
          flattened.push(part);
        }

        return flattened;
      }

      repeat(algList, accordingTo) {
        var once,
            amount = Math.abs(accordingTo.amount);
        once = -1 == (accordingTo.amount > 0 ? 1 : -1) ? invert(new Sequence(algList)).nestedUnits : algList;

        for (var repeated = [], i = 0; i < amount; i++) repeated = repeated.concat(once);

        return new Sequence(repeated);
      }

      traverseSequence(sequence) {
        return new Sequence(this.flattenSequenceOneLevel(sequence.nestedUnits.map(a => this.traverse(a))));
      }

      traverseGroup(group) {
        return this.repeat(this.flattenSequenceOneLevel([this.traverse(group.nestedSequence)]), group);
      }

      traverseBlockMove(blockMove) {
        return blockMove;
      }

      traverseCommutator(commutator) {
        var expandedA = this.traverseSequence(commutator.A),
            expandedB = this.traverseSequence(commutator.B),
            once = [];
        return once = once.concat(expandedA, expandedB, invert(expandedA), invert(expandedB)), this.repeat(this.flattenSequenceOneLevel(once), commutator);
      }

      traverseConjugate(conjugate) {
        var expandedA = this.traverseSequence(conjugate.A),
            expandedB = this.traverseSequence(conjugate.B),
            once = [];
        return once = once.concat(expandedA, expandedB, invert(expandedA)), this.repeat(this.flattenSequenceOneLevel(once), conjugate);
      }

      traversePause(pause) {
        return pause;
      }

      traverseNewLine(newLine) {
        return newLine;
      }

      traverseCommentShort(commentShort) {
        return commentShort;
      }

      traverseCommentLong(commentLong) {
        return commentLong;
      }

    }(),
          structureEqualsInstance = new class traversal_StructureEquals extends traversal_TraversalDownUp {
      traverseSequence(sequence, dataDown) {
        if (isUnit(dataDown)) return !1;
        const dataDownSeq = dataDown;
        if (sequence.nestedUnits.length !== dataDownSeq.nestedUnits.length) return !1;

        for (var i = 0; i < sequence.nestedUnits.length; i++) if (!this.traverse(sequence.nestedUnits[i], dataDownSeq.nestedUnits[i])) return !1;

        return !0;
      }

      traverseGroup(group, dataDown) {
        return matchesAlgType(dataDown, "group") && this.traverse(group.nestedSequence, dataDown.nestedSequence);
      }

      traverseBlockMove(blockMove, dataDown) {
        return matchesAlgType(dataDown, "blockMove") && blockMove.outerLayer === dataDown.outerLayer && blockMove.innerLayer === dataDown.innerLayer && blockMove.family === dataDown.family && blockMove.amount === dataDown.amount;
      }

      traverseCommutator(commutator, dataDown) {
        return matchesAlgType(dataDown, "commutator") && this.traverse(commutator.A, dataDown.A) && this.traverse(commutator.B, dataDown.B);
      }

      traverseConjugate(conjugate, dataDown) {
        return matchesAlgType(dataDown, "conjugate") && this.traverse(conjugate.A, dataDown.A) && this.traverse(conjugate.B, dataDown.B);
      }

      traversePause(pause, dataDown) {
        return matchesAlgType(dataDown, "pause");
      }

      traverseNewLine(newLine, dataDown) {
        return matchesAlgType(dataDown, "newLine");
      }

      traverseCommentShort(commentShort, dataDown) {
        return matchesAlgType(dataDown, "commentShort") && commentShort.comment == dataDown.comment;
      }

      traverseCommentLong(commentLong, dataDown) {
        return matchesAlgType(dataDown, "commentLong") && commentLong.comment == dataDown.comment;
      }

    }(),
          coalesceBaseMovesInstance = new class traversal_CoalesceBaseMoves extends traversal_TraversalUp {
      sameBlock(moveA, moveB) {
        return moveA.outerLayer === moveB.outerLayer && moveA.innerLayer === moveB.innerLayer && moveA.family === moveB.family;
      }

      traverseSequence(sequence) {
        var coalesced = [];

        for (const part of sequence.nestedUnits) if (matchesAlgType(part, "blockMove")) {
          if (coalesced.length > 0) {
            var last = coalesced[coalesced.length - 1];

            if (matchesAlgType(last, "blockMove") && this.sameBlock(last, part)) {
              var amount = last.amount + part.amount;
              coalesced.pop(), 0 !== amount && coalesced.push(new block_move_BlockMove(part.outerLayer, part.innerLayer, part.family, amount));
            } else coalesced.push(part);
          } else coalesced.push(part);
        } else coalesced.push(this.traverseIntoUnit(part));

        return new Sequence(coalesced);
      }

      traverseGroup(group) {
        return group;
      }

      traverseBlockMove(blockMove) {
        return blockMove;
      }

      traverseCommutator(commutator) {
        return commutator;
      }

      traverseConjugate(conjugate) {
        return conjugate;
      }

      traversePause(pause) {
        return pause;
      }

      traverseNewLine(newLine) {
        return newLine;
      }

      traverseCommentShort(commentShort) {
        return commentShort;
      }

      traverseCommentLong(commentLong) {
        return commentLong;
      }

    }(),
          algToStringInstance = new class traversal_ToString extends traversal_TraversalUp {
      repetitionSuffix(amount) {
        var absAmount = Math.abs(amount),
            s = "";
        return 1 !== absAmount && (s += String(absAmount)), absAmount !== amount && (s += "'"), s;
      }

      spaceBetween(u1, u2) {
        return matchesAlgType(u1, "pause") && matchesAlgType(u2, "pause") ? "" : " ";
      }

      traverseSequence(sequence) {
        var output = "";

        if (sequence.nestedUnits.length > 0) {
          output += this.traverse(sequence.nestedUnits[0]);

          for (var i = 1; i < sequence.nestedUnits.length; i++) output += this.spaceBetween(sequence.nestedUnits[i - 1], sequence.nestedUnits[i]), output += this.traverse(sequence.nestedUnits[i]);
        }

        return output;
      }

      traverseGroup(group) {
        return "(" + this.traverse(group.nestedSequence) + ")" + this.repetitionSuffix(group.amount);
      }

      traverseBlockMove(blockMove) {
        var out = blockMove.family + this.repetitionSuffix(blockMove.amount);
        return void 0 !== blockMove.innerLayer && (out = String(blockMove.innerLayer) + out, void 0 !== blockMove.outerLayer && (out = String(blockMove.outerLayer) + "-" + out)), out;
      }

      traverseCommutator(commutator) {
        return "[" + this.traverse(commutator.A) + ", " + this.traverse(commutator.B) + "]" + this.repetitionSuffix(commutator.amount);
      }

      traverseConjugate(conjugate) {
        return "[" + this.traverse(conjugate.A) + ": " + this.traverse(conjugate.B) + "]" + this.repetitionSuffix(conjugate.amount);
      }

      traversePause(pause) {
        return ".";
      }

      traverseNewLine(newLine) {
        return "\n";
      }

      traverseCommentShort(commentShort) {
        return "//" + commentShort.comment;
      }

      traverseCommentLong(commentLong) {
        return "/*" + commentLong.comment + "*/";
      }

    }(),
          invert = invertInstance.traverseSequence.bind(invertInstance),
          expand = expandInstance.traverseSequence.bind(expandInstance),
          structureEquals = structureEqualsInstance.traverseSequence.bind(structureEqualsInstance),
          coalesceBaseMoves = coalesceBaseMovesInstance.traverseSequence.bind(coalesceBaseMovesInstance),
          algToString = algToStringInstance.traverseSequence.bind(algToStringInstance);
    algToStringInstance.traverse.bind(algToStringInstance), algToStringInstance.traverse.bind(algToStringInstance);
    var example_Example, Example;

    function fromJSON(json) {
      if ("sequence" !== json.type) throw `Expected Sequence while parsing, got: ${json.type}`;
      if (!json.nestedUnits) throw "Missing nestedUnits";
      return new Sequence(json.nestedUnits.map(j => function unitFromJSON(json) {
        switch (json.type) {
          case "sequence":
            throw "Expected AlgPart while parsing, got `Sequence`.";

          case "group":
            if (!json.nestedSequence) throw "Missing nestedSequence";
            if (!json.amount) throw "Missing amount";
            return new Group(fromJSON(json.nestedSequence), json.amount);

          case "blockMove":
            if (!json.family) throw "Missing family";
            if (!json.amount) throw "Missing amount";
            return new block_move_BlockMove(json.outerLayer, json.innerLayer, json.family, json.amount);

          case "commutator":
            if (!json.A) throw "Missing A";
            if (!json.B) throw "Missing B";
            if (!json.amount) throw "Missing amount";
            return new Commutator(fromJSON(json.A), fromJSON(json.B), json.amount);

          case "conjugate":
            if (!json.A) throw "Missing A";
            if (!json.B) throw "Missing B";
            if (!json.amount) throw "Missing amount";
            return new Conjugate(fromJSON(json.A), fromJSON(json.B), json.amount);

          case "pause":
            return new Pause();

          case "newLine":
            return new NewLine();

          case "commentShort":
            if (!json.comment) throw "Missing comment";
            return new CommentShort(json.comment);

          case "commentLong":
            if (!json.comment) throw "Missing comment";
            return new CommentLong(json.comment);

          default:
            throw `Unknown alg type: ${json.type}`;
        }
      }(j)));
    }

    (Example = example_Example || (example_Example = {})).Sune = new Sequence([BareBlockMove("R", 1), BareBlockMove("U", 1), BareBlockMove("R", -1), BareBlockMove("U", 1), BareBlockMove("R", 1), BareBlockMove("U", -2), BareBlockMove("R", -1)]), Example.AntiSune = new Sequence([BareBlockMove("R", 1), BareBlockMove("U", 2), BareBlockMove("R", -1), BareBlockMove("U", -1), BareBlockMove("R", 1), BareBlockMove("U", -1), BareBlockMove("R", -1)]), Example.SuneCommutator = new Sequence([new Commutator(new Sequence([BareBlockMove("R", 1), BareBlockMove("U", 1), BareBlockMove("R", -2)]), new Sequence([new Conjugate(new Sequence([BareBlockMove("R", 1)]), new Sequence([BareBlockMove("U", 1)]), 1)]), 1)]), Example.Niklas = new Sequence([BareBlockMove("R", 1), BareBlockMove("U", -1), BareBlockMove("L", -1), BareBlockMove("U", 1), BareBlockMove("R", -1), BareBlockMove("U", -1), BareBlockMove("L", 1), BareBlockMove("U", 1)]), Example.EPerm = new Sequence([BareBlockMove("x", -1), new Commutator(new Sequence([new Conjugate(new Sequence([BareBlockMove("R", 1)]), new Sequence([BareBlockMove("U", -1)]))]), new Sequence([BareBlockMove("D", 1)]), 1), new Commutator(new Sequence([new Conjugate(new Sequence([BareBlockMove("R", 1)]), new Sequence([BareBlockMove("U", 1)]))]), new Sequence([BareBlockMove("D", 1)]), 1), BareBlockMove("x", 1)]), Example.FURURFCompact = new Sequence([new Conjugate(new Sequence([BareBlockMove("F", 1)]), new Sequence([new Commutator(new Sequence([BareBlockMove("U", 1)]), new Sequence([BareBlockMove("R", 1)]), 1)]), 1)]), Example.APermCompact = new Sequence([new Conjugate(new Sequence([BareBlockMove("R", 2)]), new Sequence([new Commutator(new Sequence([BareBlockMove("F", 2)]), new Sequence([BareBlockMove("R", -1), BareBlockMove("B", -1), BareBlockMove("R", 1)]), 1)]), 1)]), Example.FURURFMoves = new Sequence([BareBlockMove("F", 1), BareBlockMove("U", 1), BareBlockMove("R", 1), BareBlockMove("U", -1), BareBlockMove("R", -1), BareBlockMove("F", -1)]), Example.TPerm = new Sequence([BareBlockMove("R", 1), BareBlockMove("U", 1), BareBlockMove("R", -1), BareBlockMove("U", -1), BareBlockMove("R", -1), BareBlockMove("F", 1), BareBlockMove("R", 2), BareBlockMove("U", -1), BareBlockMove("R", -1), BareBlockMove("U", -1), BareBlockMove("R", 1), BareBlockMove("U", 1), BareBlockMove("R", -1), BareBlockMove("F", -1)]), Example.HeadlightSwaps = new Sequence([new Conjugate(new Sequence([BareBlockMove("F", 1)]), new Sequence([new Commutator(new Sequence([BareBlockMove("R", 1)]), new Sequence([BareBlockMove("U", 1)]), 3)]), 1)]), Example.TriplePause = new Sequence([new Pause(), new Pause(), new Pause()]), Example.AllAlgParts = [new Sequence([BareBlockMove("R", 1), BareBlockMove("U", -1)]), new Group(new Sequence([BareBlockMove("F", 1)]), 2), BareBlockMove("R", 2), new Commutator(new Sequence([BareBlockMove("R", 2)]), new Sequence([BareBlockMove("U", 2)]), 2), new Conjugate(new Sequence([BareBlockMove("L", 2)]), new Sequence([BareBlockMove("D", -1)]), 2), new Pause(), new NewLine(), new CommentShort("short comment"), new CommentLong("long comment")];

    var jison_parser = __webpack_require__(0);

    class ValidationError extends Error {}

    class validation_ValidatorTraversal extends traversal_TraversalUp {}

    function validateFamily(family, allowedFamilyLists) {
      for (const list of allowedFamilyLists) if (!0 === list[family]) return !0;

      return !1;
    }

    var plainMoveFamilies = {
      x: !0,
      y: !0,
      z: !0,
      M: !0,
      E: !0,
      S: !0,
      m: !0,
      e: !0,
      s: !0
    },
        singleSliceMoveFamilies = {
      U: !0,
      L: !0,
      F: !0,
      R: !0,
      B: !0,
      D: !0
    },
        wideMoveFamilies = {
      u: !0,
      l: !0,
      f: !0,
      r: !0,
      b: !0,
      d: !0,
      Uw: !0,
      Lw: !0,
      Fw: !0,
      Rw: !0,
      Bw: !0,
      Dw: !0
    };

    class BaseMoveValidator extends validation_ValidatorTraversal {
      traverseSequence(sequence) {
        for (const unit of sequence.nestedUnits) this.traverse(unit);
      }

      traverseGroup(group) {
        return this.traverse(group.nestedSequence);
      }

      traverseCommutator(commutator) {
        this.traverse(commutator.A), this.traverse(commutator.B);
      }

      traverseConjugate(conjugate) {
        this.traverse(conjugate.A), this.traverse(conjugate.B);
      }

      traversePause(pause) {}

      traverseNewLine(newLine) {}

      traverseCommentShort(commentShort) {}

      traverseCommentLong(commentLong) {}

    }

    const BlockMoveValidatorInstance = new class BlockMoveValidator extends BaseMoveValidator {
      traverseBlockMove(blockMove) {
        if (void 0 === blockMove.outerLayer) {
          if (void 0 === blockMove.innerLayer) {
            if (!validateFamily(blockMove.family, [wideMoveFamilies, singleSliceMoveFamilies, plainMoveFamilies])) throw new ValidationError(`Invalid SiGN plain move family: ${blockMove.family}`);
          } else {
            if (!validateFamily(blockMove.family, [wideMoveFamilies, singleSliceMoveFamilies])) throw new ValidationError(`The provided SiGN move family is invalid, or cannot have an inner slice: ${blockMove.family}`);
            if (blockMove.innerLayer <= 0) throw new ValidationError("Cannot have an inner layer of 0 or less.");
          }
        } else {
          if (void 0 === blockMove.innerLayer) throw new ValidationError("A BlockMove with an outer layer must have an inner layer.");
          if (!validateFamily(blockMove.family, [wideMoveFamilies])) throw new ValidationError(`The provided SiGN move family is invalid, or cannot have an outer and inner layer: ${blockMove.family}`);
          if (blockMove.outerLayer <= 0) throw new ValidationError("Cannot have an outer layer of 0 or less.");
          if (blockMove.outerLayer >= blockMove.innerLayer) throw new ValidationError("The outer layer must be less than the inner layer.");
        }
      }

    }(),
          validateSiGNMoves = BlockMoveValidatorInstance.traverse.bind(BlockMoveValidatorInstance),
          flatAlgValidatorInstance = new class FlatAlgValidator extends validation_ValidatorTraversal {
      traverseSequence(sequence) {
        for (const unit of sequence.nestedUnits) this.traverse(unit);
      }

      traverseGroup(group) {
        throw new ValidationError("A flat alg cannot contain a group.");
      }

      traverseBlockMove(blockMove) {}

      traverseCommutator(commutator) {
        throw new ValidationError("A flat alg cannot contain a commutator.");
      }

      traverseConjugate(conjugate) {
        throw new ValidationError("A flat alg cannot contain a conjugate.");
      }

      traversePause(pause) {}

      traverseNewLine(newLine) {}

      traverseCommentShort(commentShort) {}

      traverseCommentLong(commentLong) {}

    }(),
          validateFlatAlg = flatAlgValidatorInstance.traverse.bind(flatAlgValidatorInstance),
          validateSiGNAlg = function (a) {
      validateSiGNMoves(a), validateFlatAlg(a);
    };

    function parse(s, options = {
      validators: []
    }) {
      options.validators = options.validators || [];
      const algo = fromJSON(Object(jison_parser.parse)(s));

      for (const validate of options.validators) validate(algo);

      return algo;
    }

    const cubeKeyMapping = {
      73: BareBlockMove("R"),
      75: BareBlockMove("R", -1),
      87: BareBlockMove("B"),
      79: BareBlockMove("B", -1),
      83: BareBlockMove("D"),
      76: BareBlockMove("D", -1),
      68: BareBlockMove("L"),
      69: BareBlockMove("L", -1),
      74: BareBlockMove("U"),
      70: BareBlockMove("U", -1),
      72: BareBlockMove("F"),
      71: BareBlockMove("F", -1),
      78: BareBlockMove("F"),
      86: BareBlockMove("F", -1),
      67: BareBlockMove("l"),
      82: BareBlockMove("l", -1),
      85: BareBlockMove("r"),
      77: BareBlockMove("r", -1),
      84: BareBlockMove("x"),
      89: BareBlockMove("x"),
      66: BareBlockMove("x", -1),
      186: BareBlockMove("y"),
      59: BareBlockMove("y"),
      65: BareBlockMove("y", -1),
      80: BareBlockMove("z"),
      81: BareBlockMove("z", -1),
      190: BareBlockMove("M", -1)
    };

    function keyToMove(e) {
      return e.altKey || e.ctrlKey ? null : cubeKeyMapping[e.keyCode] || null;
    }

    function serializeURLParam(a) {
      var escaped = algToString(a);
      return escaped = (escaped = (escaped = escaped.replace(/_/g, "&#95;").replace(/ /g, "_")).replace(/\+/g, "&#2b;")).replace(/-/g, "&#45;").replace(/'/g, "-");
    }

    function deserializeURLParam(a) {
      var unescaped = a;
      return parse(unescaped = (unescaped = (unescaped = unescaped.replace(/-/g, "'").replace(/&#45;/g, "-")).replace(/\+/g, " ").replace(/&#2b;/g, "+")).replace(/_/g, " ").replace(/&#95;/g, "_"));
    }

    function getAlgURLParam(name) {
      return deserializeURLParam(new URLSearchParams(window.location.search).get(name) || "");
    }

    function algCubingNetLink(options) {
      var url = new URL("https://alg.cubing.net");
      if (!options.alg) throw "An alg parameter is required.";

      if (url.searchParams.set("alg", serializeURLParam(options.alg)), options.setup && url.searchParams.set("setup", serializeURLParam(options.setup)), options.title && url.searchParams.set("title", options.title), options.puzzle) {
        if (-1 === ["1x1x1", "2x2x2", "3x3x3", "4x4x4", "5x5x5", "6x6x6", "7x7x7", "8x8x8", "9x9x9", "10x10x10", "11x11x11", "12x12x12", "13x13x13", "14x14x14", "16x16x16", "17x17x17"].indexOf(options.puzzle)) throw `Invalid puzzle parameter: ${options.puzzle}`;
        url.searchParams.set("puzzle", options.puzzle);
      }

      if (options.stage) {
        if (-1 === ["full", "cross", "F2L", "LL", "OLL", "PLL", "CLS", "ELS", "L6E", "CMLL", "WV", "ZBLL", "void"].indexOf(options.stage)) throw `Invalid stage parameter: ${options.stage}`;
        url.searchParams.set("stage", options.stage);
      }

      if (options.view) {
        if (-1 === ["editor", "playback", "fullscreen"].indexOf(options.view)) throw `Invalid view parameter: ${options.view}`;
        url.searchParams.set("view", options.view);
      }

      if (options.type) {
        if (-1 === ["moves", "reconstruction", "alg", "reconstruction-end-with-setup"].indexOf(options.type)) throw `Invalid type parameter: ${options.type}`;
        url.searchParams.set("type", options.type);
      }

      return url.toString();
    }

    __webpack_require__.d(__webpack_exports__, "AlgPart", function () {
      return AlgPart;
    }), __webpack_require__.d(__webpack_exports__, "Unit", function () {
      return Unit;
    }), __webpack_require__.d(__webpack_exports__, "Move", function () {
      return Move;
    }), __webpack_require__.d(__webpack_exports__, "Container", function () {
      return Container;
    }), __webpack_require__.d(__webpack_exports__, "Annotation", function () {
      return Annotation;
    }), __webpack_require__.d(__webpack_exports__, "Sequence", function () {
      return Sequence;
    }), __webpack_require__.d(__webpack_exports__, "Group", function () {
      return Group;
    }), __webpack_require__.d(__webpack_exports__, "BlockMove", function () {
      return block_move_BlockMove;
    }), __webpack_require__.d(__webpack_exports__, "BareBlockMove", function () {
      return BareBlockMove;
    }), __webpack_require__.d(__webpack_exports__, "LayerBlockMove", function () {
      return LayerBlockMove;
    }), __webpack_require__.d(__webpack_exports__, "RangeBlockMove", function () {
      return RangeBlockMove;
    }), __webpack_require__.d(__webpack_exports__, "Commutator", function () {
      return Commutator;
    }), __webpack_require__.d(__webpack_exports__, "Conjugate", function () {
      return Conjugate;
    }), __webpack_require__.d(__webpack_exports__, "Pause", function () {
      return Pause;
    }), __webpack_require__.d(__webpack_exports__, "NewLine", function () {
      return NewLine;
    }), __webpack_require__.d(__webpack_exports__, "CommentShort", function () {
      return CommentShort;
    }), __webpack_require__.d(__webpack_exports__, "CommentLong", function () {
      return CommentLong;
    }), __webpack_require__.d(__webpack_exports__, "TraversalDownUp", function () {
      return traversal_TraversalDownUp;
    }), __webpack_require__.d(__webpack_exports__, "TraversalUp", function () {
      return traversal_TraversalUp;
    }), __webpack_require__.d(__webpack_exports__, "invert", function () {
      return invert;
    }), __webpack_require__.d(__webpack_exports__, "expand", function () {
      return expand;
    }), __webpack_require__.d(__webpack_exports__, "structureEquals", function () {
      return structureEquals;
    }), __webpack_require__.d(__webpack_exports__, "coalesceBaseMoves", function () {
      return coalesceBaseMoves;
    }), __webpack_require__.d(__webpack_exports__, "algToString", function () {
      return algToString;
    }), __webpack_require__.d(__webpack_exports__, "Example", function () {
      return example_Example;
    }), __webpack_require__.d(__webpack_exports__, "fromJSON", function () {
      return fromJSON;
    }), __webpack_require__.d(__webpack_exports__, "parse", function () {
      return parse;
    }), __webpack_require__.d(__webpack_exports__, "keyToMove", function () {
      return keyToMove;
    }), __webpack_require__.d(__webpack_exports__, "validateSiGNMoves", function () {
      return validateSiGNMoves;
    }), __webpack_require__.d(__webpack_exports__, "validateFlatAlg", function () {
      return validateFlatAlg;
    }), __webpack_require__.d(__webpack_exports__, "validateSiGNAlg", function () {
      return validateSiGNAlg;
    }), __webpack_require__.d(__webpack_exports__, "ValidationError", function () {
      return ValidationError;
    }), __webpack_require__.d(__webpack_exports__, "serializeURLParam", function () {
      return serializeURLParam;
    }), __webpack_require__.d(__webpack_exports__, "deserializeURLParam", function () {
      return deserializeURLParam;
    }), __webpack_require__.d(__webpack_exports__, "algCubingNetLink", function () {
      return algCubingNetLink;
    }), __webpack_require__.d(__webpack_exports__, "getAlgURLParam", function () {
      return getAlgURLParam;
    }), __webpack_require__.d(__webpack_exports__, "setAlgPartTypeMismatchReportingLevel", function () {
      return setAlgPartTypeMismatchReportingLevel;
    });
  }]);
});